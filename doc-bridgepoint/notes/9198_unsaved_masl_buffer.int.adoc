= Unsaved editor changes in a MASL editor are wiped out by a structural change

== 1 Abstract

From the issue description:

> While editing a domain service if the user makes a change to the model before
> saving the editor change the editor change is lost, the editor is reset to what
> is was before the structure change.

== 2 Introduction and Background

xtUML elements are stored in `.xtuml` files. Related elements are grouped
together in a
tree-like structure under a "root" element which determines the file boundaries.
Root elements include the project itself, packages, components, classes, and
state machines.

MASL activity bodies are stored in separate `.masl` files which correspond to
the `.xtuml` file which contains the definition and signature of the activity
element itself. At load time, each individual action body is parsed and injected
into the in-memory xtUML instances.

When the user makes a change to a model element, the transaction manager
initiates a persist operation on only the root elements which have been
affected. This results in the writing of the `.xtuml` file for that model root
and the `.masl` file if any child elements contain MASL action bodies.

Ideally, if an unsaved MASL buffer is open and the structural model changes, the
buffer should be unaffected unless the signature of the particular body is
affected. In that case, the user should be notified and given the option to save
the contents and continue or to cancel the edit operation.

One complicating factor is the rename/refactor behavior of the MASL plugin. When
a structural element changes, the MASL plugin finds all references to the
element in the MASL activities and replaces the old names with the new element
name. This means that a buffer can theoretically be affected by a change in
almost any other model root. I believe this was introduced to make sure that any
open buffers get refreshed after a rename/refactor operation or another model
load (such as from disk). TODO link #9354

I do not think there is an easy way to determine if a particular action body has
changed as the result of a model load, so without getting into the weeds of
rename/refactor and persistence, it would be difficult to synchronize only
buffers with new changes. Given this this restriction, there are two potential
solutions to this problem:

1. Force "dirty" MASL buffers to persist before they are synchronized
2. Skip synchronization of "dirty" MASL buffers which have changes

Both of these solutions have the downside that they lose any changes to the
bodies that may be part of the model load (e.g. editing the `.masl` file outside
of Eclipse or rename/refactor). Essentially, the editor would always prefer the
current editor contents over changes on disk. It is my personal opinion that
this is a worthwhile trade-off as it should be relatively rare and the impact is
limited to only the current "dirty" MASL buffers.

== 3 Requirements

=== 3.1 Changes in "dirty" MASL buffers shall not be discarded after a structural model element change

== 4 Work Required

Elaborate on each point of the Work Required section of the design note and
describe how you implemented each step.  If there is no design note, this
section, breaks out the consequential work (as a numbered list) needed to
meet the requirements specified in the Requirements section.

== 5 Implementation Comments

If the design cannot be implemented as written or if it needs some
modification, enumerate the changes to the design in this section.
If there was no preceding design note, then this section documents
any deviations from the implementation as presented at the
pre-implementation engineering review.

.Recommended Type Mapping
[options="header"]
|===
| MASL type  | xtUML type recommendation
| boolean    | Use native `boolean`
| byte       | Create UDT with core type `integer`
| character  | Create UDT with core type `integer`
|===

=== 5.1 Item 1

[source,java]
----
    // java code example
    public void clearDatabase(IProgressMonitor pm)
    {
        // clear the corresponding graphics-root's database
        OoaofgraphicsUtil.clearGraphicsDatabase(rootId, pm);

        Ooaofooa.getDefaultInstance().fireModelElementUnloaded(this);
    }
----

==== 5.1.1 Example sub-item

== 6 Unit Test

Outline all the unit tests that need to pass and describe the method that you
will use to design and perform the tests.

. Here is another ordered list element allowing the renderer to do the work.
  This may be better for unit test steps that do not get explicitly referenced.
. second one
  .. enumerated sub first
  .. enumerated sub second
. third

== 7 User Documentation

Describe the end user documentation that was added for this change.

== 8 Code Changes

- fork/repository:  your_fork/repo_name
- branch:  your_branch_name_here

----
 Put the file list here
----

== 9 Document References

In this section, list all the documents that the reader may need to refer to.
Give the full path to reference a file.

. [[dr-1]] https://support.onefact.net/issues/NNNNN[NNNNN - headline]
. [[dr-2]] ...
. [[dr-3]] link:../8073_masl_parser/8277_serial_masl_spec.md[Serial MASL (SMASL) Specification]

---

This work is licensed under the Creative Commons CC0 License

---
