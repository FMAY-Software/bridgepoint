= Textual Specification of xtUML

== 1 Abstract

This document defines the textual representation of the xtUML modeling language.

== 2 Introduction and Background

It has long been a goal to migrate away from instance-based persistence of
xtUML models as SQL insert statments and to a semantic text based format. There
are several benefits to this, but here are two of the most important:

- Human readable/editable without a dedicated tool
- Diff/mergable

Additionally, having a textual language lowers the barrier to participation
from the rest of the community for both modeling and tool development.
 
In order to persist to a text format, a textual specification is required. The
following document aims to define such a specification. The specification is
based on the exsting MASL language (TODO ref) with some modification and
extensions for constructs that do not exist in MASL. In order to produce a
concise language devoid of useless clutter, some editorial license will be
taken to remove capabilities supported by the current xtUML metamodel when
appropriate. Deviations from standard MASL and omissions from the xtUML
metamodel will be called out explicitly by this document.

Throughout this document the terms "spec" and "specification" shall be
understood to refer to the textual specification of xtUML.

There are many details that are critical to an implementation of the language
by a tool but are not an official part of the specification. This document
will provide suggestions for implementation in these cases.

Some terms differ between MASL and xtUML method implementations. For the sake
of clarity in this document, the xtUML terms will be preferred but the
following can be regarded as synonyms:

- component = domain
- class = object
- deployment = MASL "project"
- port = terminator
- relationship = association
- TODO are there more?

Grammar snippets are shown in ANTLR syntax

== 3 Requirements

=== 3.1 A specification shall be created to define the textual representation of xtUML models
==== 3.1.1 The spec shall not include a specification of action language within executable bodies

=== 3.2 The spec shall support existing MASL models with minimal modification
==== 3.2.1 Required modifications of MASL models shall be able to be easily automated

== 4 Analysis

=== 4.1 General structure

An xtUML model is defined by a loosely associated group of model elements.

Structural model elements are defined within `.xtuml` files. MASL file
extesions are recognized for backwards compatibility. Action bodies are defined
within files with an extention which specifies the action language dialect (e.g
`.oal`, `.masl`, `.asl`). MASL file extensions are recognized for backwards
compatibility and are assumed to be MASL. A file name may be based on the
principal element contained with in it, however the file name is not
semantically relevant and is at the discretion of the tool implementation.

It is not recommended to mix action dialects within a model, but it is not
restricted by this spec.

There is no concept of a "project". Typically a group of related model elements
will be packaged together in a group of files within a single filesystem tree,
however, a model may be expressed by a flat group of files or files may be
referenced from disconnected filesystem trees. An entire model may be defined
within one file. The directory structure is at the discretion of the tool and
is not a part of the spec.

Logically, a group of model files behaves as though all files have been
concatenated together before parsing. There is no restriction of the order in
which root model elements are defined. If action bodies are defined within an `.xtuml`
file, it is up to the implementation to distinguish the dialect (perhaps by a
parser flag or preference within the tool).

The suggested implementation of tree structure is as follows:

- All structural files use the `.xtuml` extension. All action body files
- File names are defined by the simple name (TODO see naming below) of the
  principal element within the file
- Packages and components are "containing elements" and are defined in their
  own file as the principal element within a directory also named according to
  the simple name of the element
- A single action body file is defined for each package and component and are named
  the same as the `.xtuml` file but with the appropriate file extension for the
  dialect
- Action body files are excluded if there are no exectable model elements
  defined within the container or if there are no non-empty bodies within the
  container (TODO see action bodies below)

Note: this structure is similar to current BridgePoint persistence, however
classes, state machines, etc. would not get their own files

See the following example:
```
EclipseProject/
|─ gen/
|─ models/
|  |─ package1/
|     |─ component1/
|     |  |─ package2/
|     |  |  |─ package2.oal
|     |  |  |─ package2.xtuml
|     |  |─ component1.oal
|     |  |─ component1.xtuml
|     |─ package1.xtuml
|─ .project
```

==== 4.1.1 Root model elements, packageable model elements, and containment

Root model elements are elements that may be defined at the root of a file.
Root model elements are:

- Package
- Component
- Action body definition
  - State entry action
  - Transition action
  - Function
  - Class/instance operation
  - Bridge
  - Port message

Packageable model elements are elements which may be defined within a package
or component and included in a component definition (domain). Packageable model
elements are:

- Class
- Component
- Constant specification
- Deployment
- Exception
- External entity
- Interface
- Package
- Package reference
- Relationship (association)
- Function
- Satisfaction
- Type

Non-packageable model elements are elements which are defined directly within
the component to which they belong. Non-packageable elements are:

- Port
- Port reference (delegated port)

Model elements may be contained within other components. For example, a package
may contain class definitions; an operation may contain parameters. An element
is said to be contained by another element if it is directly defined within the
other element, or if it is contained by an element which is also contained by
the other element in question (indirect containment).

Packages and components are both root elements and packageable elements. If a
package which is defined at root of a file, but is logically defined within
another package, it can specify its direct parent with the `within` keyword.
For example:

```
package OuterPackage is
  
  package InnerPackage is
  end package;

end package;
```

is semantically equaivalent to:
```
package OuterPackage is
end package;

package InnerPackage within OuterPackage is
end package;
```

This construct allows packages and components to be defined in their own files
even when they are contained by other packages/components.

Note: As defined, classes, state machines, etc may _not_ be defined in their
own files.

=== 4.2 Element visibility

The component is the unit of visibility. Elements defined within a component
may not reference elements defined outside the component unless they are
defined within a package which is imported into the component through a package
reference.

Non-packageable elements defined within a component may not be referenced by
any element defined outside the component.

Packageable elements defined outside any component may reference any other
element defined outside a component If an element which is defined outside a
component is imported into a component through a package reference and
subsequently loses visibility to other model elements it or its contained
elements refer to, an error is raised. In this situation, all elements
connected in a reference network must be imported into the component.

Note: There is currently no warning for this situation in BridgePoint and it is
a common failure mode in generating code.

Within a component, all elements are visible to all other elements. If
components are nested, the same visibility boundary applies and the inner
component must import any packages that it may refer to from the outer
component.

Action statements have the visibility of the component in which they are
defined or imported.

==== 4.2.1 Visibility exceptions

Public functions are an exception to the component-level visibility rule.
public functions. Functions defined as public within a component may be invoked
by action language statements in other visible components.

Satisfactions may reference ports within visible components.

Deployments are considered to be equivalent to components for visibility
purposes.

=== 4.3 Named elements

All packageable and non-packageable model elements are named elements. All
named elements have a simple name. Some named elements can have an optional
extended name. Some named elements may optionally have no name (e.g.
satisfactions).

The following elements support extended names:

- Class
- Component
- Package
- Event
- State
- TODO more?

The simple name is an identifier composed of alphanumeric characters and
underscores. Simple names may not contain spaces or start with numerical
digits. The simple name is analagous to key letters for classes and external
entities, but generalized for all elements.

```
SimpleName:  ('A'..'Z' | 'a'..'z' | '_') ('A'..'Z' | 'a'..'z' | '0'..'9' | '_')*;
```

Extended names are composed of a string of characters enclosed in single
quotes. There is no restrictions on characters within extended names except
they may not include single quotes or line breaks.

```
ExtendedName:  '\'' ( ~('\'' | NEWLINE) )+ '\'';
```

An element name may be specified in two ways. Simple name only as follows:
```
class Dog is
  ...
```

Extended name with simple name as follows:
```
class 'Dog Owner'[DogOwner] is
  ...
```

==== 4.3.1 Referencing named elements

A named element's simple name is used exclusively for making named references
to other model elements.

The extended name may be used for display and debugging, but is never used for
any semantic purpose.

A named element has a fully qualified name defined as a sequence of name
segments separated by double colons (`::`). The fully qualified name starts
with the simple name of the root component which contains the defined component
and continues through the element's ancestors until the element is reached.

For example, the parameter `param1` in the following example:
```
package package1 is

  component component1 is

    package package2 is

      function foo(param1: in integer);

    end package;

  end component;

end package;
```

has a fully qualified name: `package1::component1::package2::foo::param1`.

Named elements may always be referenced by their fully qualified name.

Named elements in the same visibility context may be referenced by their
siblings by their simple name only.

If a name conflict exists in the visibility context, an element may need to be
referenced by partially qualified name. Consider the following example:

```
TODO some nice example with types of the same name
```
=== 4.4 Model elements

==== 4.4.1 Package

Packages are the basic unit of containment for packageable elements. Packages
have the property of being able to be imported, so they are useful for grouping
related model elements for reuse in multiple domains. A package is defined as follows:

```
'package' Name ( 'within' ElementReference )? 'is'
  
  PackageableElement*

'end package' ';'
```

Packages may be defined within another package or component syntactically or
they may be defined at the root of a model file. The `within` part of the
definition is valid if and only if the package is defined at the root level.

==== 4.4.2 Package reference

Package may be "imported" into another location using a package reference:

```
'package' Name 'is' ElementReference ';'
```

For example:

```
component component1 is

  package configuration is Library::configuration;

end component;
```

A package reference is itself a package and therefore has a name and may be
referenced by other model elements. All elements defined within the referred to
package are visible through the referring package.

Note: some elements may have more than one valid fully qualified name if they
are referenced by a package reference.

==== 4.4.3 Component

Components represent a cohesive unit of behavior in the model. Packageable and
non-packageable elements may be defined within components.

```
'component' Name ( 'within' ElementReference )? 'is'

  Element*

'end' 'component' ';'
```

Just like packages, components may be defined directly in another component or
package or at the root level.

`domain` is a lexer synonym for `component`.

==== 4.4.4 Class

```
'class' Name 'is'

  ClassItem*

'end' 'class' ';'
```

Items which may be defined in a class are:

- Attribute
- Identifier
- Operation
- Event
- State
- State machine

`object` is a lexer synonym for `class`.

TODO classes are defined just like MASL; copy spec here at some point

TODO attribute default values also support the `=` symbol (along with MASL `:=` assign

==== 4.4.5 Relationship (association)

Relationships may be simple, associative (linked), or subtype/supertype.
Relationships do not support extended names and the name of a relationship must
be with the character 'R' followed by an integer:

```
RelationshipName: 'R' ('1'..'9') ('0'..'9')*;
```

TODO relationships are defined just like MASL; copy spec here at some point

TODO Role phrases may be specified as an identifier or a single quoted literal.

Note: It is not required for classes to be defined in the same package as a
relationship which references them. Tools which have diagrams of relationships
will need to create a reference to the class in the package.

==== 4.4.6 Function

Functions represent synchronous execution within a component. Functions may be
public or private. Public functions are exposed to other action bodies in
external components. Private functions are only available to action bodies
within the defining component. If unspecified, functions are assumed to be private.

Functions may or may not have a return type.

Parameters may be "in" or "out" parameters. "in" parameters are passed by value
to the function body and are not assignable.  "out" parameters are passed by
reference to the function body and may be re-assigned by statements within the
function. If unspecified, parameters are "in".

```
('public' | 'private' | /* not specified */) ('function' | 'service') Name '(' FormalParameter* ')' ( 'return' TypeReference )? ';'
```

FormalParameter:
```
Name ':' ('in' | 'out' | /* not specified */) TypeReference
```

Note: to maintain compatibility with MASL the `service` keyword may replace `function`

==== 4.4.7 Type

Named types may be defined by the user and included within components.

TODO types are defined just like MASL; copy spec here at some point

TODO MASL supports default values for enumerators and structure members... allow this?

Note: Not all types represented in this spec are currently supported in xtUML

Note: The implementation is responsible to decide what action language dialect
is used to evaluate constant expressions used as constraints.

==== 4.4.8 Constant specification

Symbolic constants are gathered into constant groups. Constants may be defined
by a constant expression in action language or a blob of target language code.
For normal constants the implementation is responsible to decide what action
language dialect is used to evaluate the constant expressions. Normal constants
are cross platform and can be checked at compile time.

```
'constant' 'group' 'is'
  Constant*
'end 'constant' 'group' ';'
```

Normal constant:
```
Name '=' ConstantExpression ';'
```

Native constant:
```
'native' Name '=' NativeConstantExpression ';'
```

`NativeConstantExpression` is a single quoted string literal.

==== 4.4.9 Exception

TODO exceptions are defined just like MASL; copy spec here at some point

==== 4.4.10 Interface

Interfaces define an abstract set of signals which will be implemented by a port.

Signals may be "to provider" or "from provider". "to provider" signals are
received by "provided" ports which implement this interface. "from provider"
signals are received by "required" ports which implement this interface.  If
not specified, signals are "from provider".

Signals may define contracts to enforce constraints on execution. Signals which
define a return type may specify a duration for which to wait for a response.
Signals which do not define a return type may specify an inbound signal within
the same interface that it expects to receive in response and a duration within
which to expect that signal. In both cases, a user defined exception may be
specified to be raised if the contract is violated. If no exception is
specified, the target architecture is responsible for taking appropriate action
if the contract is violated.

```
'interface' 'is'
  Signal*
'end' 'interface' ';'
```

Signal:
```
'public'? ('signal' | 'service') Name '(' FormalParameter* ')' ( 'return' TypeReference )? ( ( 'from' | 'to' ) 'provider' )? ContractDefinition ';'
```

ContractDefinition:
```
( 'expects' SignalReference )? ( 'within' DurationLiteral )? ( 'raises' ExceptionReference )?
```

Note: to maintain compatibility with MASL the `service` keyword may replace `signal` and `public` may prepend the declaration.

==== 4.4.11 Port

Ports are defined directly within a component. They may not be imported into
other components. Ports may be "provided" or "required". If not specified,
ports are "required". A port may implement an interface or it may define
signals directly.

```
( 'required' | 'provided' | /* not specified */ ) 'port' Name 'implements' InterfaceReference ';'
```

Direct declaration of signals:
```
( 'required' | 'provided' | /* not specified */ ) 'port' Name 'is'
  Signal*
'end' 'port' ';'
```

Note: `terminator` is a lexer synonym for `port`

==== 4.4.12 Port reference

Port references represent the delegation of a port from an outer component to a
nested inner component. Once delegated, the reference of the outer port by an
action language body results in an error. If "required"/"provided" is
specified, it must match the referred to port. If not specified, it is
considered to be inherited from the referred to port.

```
( 'required' | 'provided' | /* not specified */ ) 'port' Name 'is' PortReference ';'
```

==== 4.4.13 External entity

External entities represent a named group of bridge operations typically to
provide utility services such as logging or math functions. External entity
bridges are considered to be synchronous and will cause execution to pause.  If
asynchronous behavior is desired, the external entity should be modeled as a
component.

```
'external' Name 'is'
  Bridge*
'end' 'external' ';'
```

Bridge:
```
'bridge' Name '(' FormalParameter* ')' ( 'return' TypeReference )? ';'
```

==== 4.4.14 Satisfaction

A satisfaction defines a connection between a required and a provided port in
two components. Multiple satisfactions may be defined referencing a single
provided port (multiple requiring ports to one provided port). Satisfactions
may be defined between a provided and required port on the same component.
Satisfactions may be unnamed, however, a name is required for them to be
referenced by marking.

```
satisfaction ( Name )? is provider=PortReference '-o)-' requirer=PortReference ';'
```

Note: It is not required for components to be defined in the same package as a
satisfaction which references them. Tools which have diagrams of satisfactions
will need to create a reference to the component in the package.

==== 4.4.15 Deployment

Deployments provide an informal system modeling mechanism by overriding
required signal implementations within a domain.

TODO deployments are defined just like MASL

Note: `project` is lexer synonym for `deployment` for MASL compatibility

=== 4.5 Element descriptions

Descriptions may be prepended on any packageable or non-packageable element.
Descriptions follow the MASL format and are defined by lines starting with the
`//!` character sequence.

```
'//!' ~('\n'|'\r')* '\r'? '\n';
```

TODO descriptions for lower level elements e.g. individual constants,
parameters, state event matrix cells

=== 4.6 Marking

TODO clarify this...

Marks are applied to model elements separate from the model itself. All named
model elements may be marked. A mark consists of a reference to the feature,
reference to the element type being marked, name of the element itself, and a
string value.

Marks are specified in a separate file in the YAML format. It is the
responsibility of the implementation to define the name and location of this
file.

At the base level of the YAML file, marks which apply to all element types are
specified as feature/value pairs.

Each element type to be marked is specified next under which marks which apply
to all elements of that tpye are specified as feature/value pairs.

Features which require an element to be specified come next. The features are
named and below is a list of name/value pairs for elements which are marked
with that feature.

See the following example:
```
---
RootPackage: 'GPS_Watch::GPS_Watch'
SortComparator: 'getName'
O_OBJ:
  UseKeyLettersForName:
    'HeartRateMonitor::HeartRateMonitor::HeartRateMonitor::HeartRateMonitor': true
  NonPersistent:
    'Tracking::Tracking::ConstantSpecifications::GoalAchievement': true
    'Tracking::Tracking::ConstantSpecifications::GoalSpecConstants': true
    'Tracking::Tracking::ConstantSpecifications::HeartRateConstants': true
    'Tracking::Tracking::ConstantSpecifications::Speed,NonPersistent': true
    'Tracking::Tracking::ConstantSpecifications::WorkoutTimerConstants': true
    'HeartRateMonitor::HeartRateMonitor::HeartRateMonitor::HeartRateConstants': true
    'Location::Location::Location::simulatedGPS': true
```

TODO unnamed elements?
TODO reference model of marking
TODO reference YAML

=== 4.x Grammars and examples

TODO

== 5 Document References

TODO

In this section, list all the documents that the reader may need to refer to.
Give the full path to reference a file.

. [[dr-1]] https://support.onefact.net/issues/NNNNN[NNNNN - headline]
. [[dr-2]] ...
. [[dr-3]] link:../8073_masl_parser/8277_serial_masl_spec.md[Serial MASL (SMASL) Specification]

---

This work is licensed under the Creative Commons CC0 License

---
