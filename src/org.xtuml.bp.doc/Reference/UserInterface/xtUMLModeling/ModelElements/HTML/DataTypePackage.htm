<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../../../../../github-pandoc.css" type="text/css" />
</head>
<body>
<h1 id="data-types">Data Types</h1>
<p>Data types fall into the following categories: * Primitive types * User data types * Structured data types * Enumerations * Constant specifications</p>
<h2 id="primitive-types">Primitive types</h2>
<p>Primitive (native) types are built-in and provided by BridgePoint. You cannot add to or remove from the set of primitive types. The primitive types are:</p>
<h3 id="void">void</h3>
<p>A primitive data type representing emptiness or nothingness.</p>
<h3 id="boolean">boolean</h3>
<p>An enumeration whose only allowable values are true and false. This type is a core data type that supports the following operators: and, or, and not.</p>
<h3 id="integer">integer</h3>
<p>A primitive data type whose literal values represent whole numbers, i.e., 1, 2, 3, and so on. The integer type supports the following arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, unary operations: <code>+</code>, <code>-</code>, and comparison operations: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</p>
<h3 id="real">real</h3>
<p>A primitive data type whose literal values represent real numbers, i.e., those that can contain a fractional part as in: 1.0, 2.4, 3.14159, and so on. The real type supports the following arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, unary operations: <code>+</code>, <code>-</code>, and comparison operations: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</p>
<h3 id="string">string</h3>
<p>A primitive data type used to define a sequence of characters. A literal string is always enclosed in a set of double quotes, for example “abcdefg”. String types support concatenation (+ operator) and the following lexical comparisons: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</p>
<h3 id="unique_id">unique_id</h3>
<p>A primitive data type that provides an arbitrary value generated by the system and guaranteed to be unique across all instances of the same class. Modelers should use an arbitrary identifier (aka unique_id) when using natural identifying attributes is either not possible or cumbersome. Only equality (<code>==</code>) and inequality (<code>!=</code>) operators are supported.</p>
<h3 id="statestate_model">state&lt;State_Model&gt;</h3>
<p>A primitive data type used internally by xtUML to keep track of the current state of classes with state diagrams. Variables of this type cannot be manipulated or assigned by the user.</p>
<h3 id="same_asbase_attribute">same_as&lt;Base_Attribute&gt;</h3>
<p>A primitive data type used internally by xtUML to make sure association referential attributes use the same type on both sides of the association. Variables of this type cannot be manipulated or assigned by the user.</p>
<h3 id="inst_refobject">inst_ref&lt;Object&gt;</h3>
<p>A primitive data type representing a reference to a modeled class. Variables created via a “create object instance”, ”select one“ or “select any” statement are of this type. Class attributes are accessed via the “.” operator.</p>
<h3 id="inst_ref_setobject">inst_ref_set&lt;Object&gt;</h3>
<p>A primitive data type representing a collection of references to a modeled class. Variables created via a ”select many” statement are of this type. Each element in the collection is of type <code>inst_ref&lt;Object&gt;</code>.</p>
<h3 id="instevent">inst&lt;Event&gt;</h3>
<p>A primitive data type representing a reference to a modeled event. Variables created via a “create event instance” statement are of this type.</p>
<h3 id="instmapping">inst&lt;Mapping&gt;</h3>
<p>A primitive data type from which a user-defined type can be derived, an instance mapping is used when an xtUML model requires access to a data structure in another xtUML model or legacy code. Although there are no hard and set rules for when to use an instance mapping over an instance reference mapping, the decision usually revolves around the operations supported.</p>
<p>Instance mappings are commonly used when manipulating the data structure as a whole.</p>
<p>All comparison operations are available for instance mappings in OAL: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>. However, due to their implementation-specific nature, Verifier cannot use variables of this type in a meaningful way.</p>
<p>The implementation of mappings and the markings used to realize them are provided by the BridgePoint Compiler. See the documentation for the marking MapDataTypeAsPointer in <code>&lt;project&gt;/gen/datatype.mark</code> for additional information.</p>
<h3 id="inst_refmapping">inst_ref&lt;Mapping&gt;</h3>
<p>A primitive data type from which a user-defined type is derived, an instance reference mapping is used when an xtUML model requires access to a data structure in another xtUML model or legacy code. Although there are no hard and set rules for when to use an instance reference mapping over an instance mapping, the decision usually revolves around the operations supported.</p>
<p>Instance reference mappings are commonly used when manipulating the data structure by reference.</p>
<p>The equality and inequality operators are available for instance reference mappings in OAL: <code>==</code>, <code>!=</code>. However, due to their implementation-specific nature, Verifier cannot use variables of this type in a meaningful way.</p>
<p>The implementation of mappings and the markings used to realize them are provided by the BridgePoint Compiler. See the documentation for the marking MapDataTypeAsPointer in <code>&lt;project&gt;/gen/datatype.mark</code> for additional information.</p>
<h3 id="component_ref">component_ref</h3>
<p>A primitive data type representing a reference to a modeled component. The sender keyword in OAL is always of this type. This type may be used the same place other primitive data types are used. It is also valid in OAL as the target in a “send ... to <code>&lt;component_ref&gt;</code>” command when performing inter-component messaging. Class attributes, parameters, return values, and transients may all use this type.</p>
<p>Variables of this type support equality and inequality operations in Verifier: <code>==</code>, <code>!=</code></p>
<p>Variables of this type are not yet supported in MC-3020.</p>
<h3 id="date">date</h3>
<p>A primitive data type representing an xtUML date. Variables created via a “TIM::create_date” or “TIM::current_date” statement are of this type. dates may be stored in class attributes, passed as parameters and return values, and manipulated via TIM bridge operations.</p>
<p>Variables of this type support equality, inequality, comparison, and assignment operations: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>=</code></p>
<h3 id="inst_reftimer">inst_ref&lt;Timer&gt;</h3>
<p>A primitive data type representing a reference to a xtUML timer. Variables created via a “TIM::timer_start” or “TIM::timer_start_recurring” statement are of this type. Timer references may be stored in class attributes, passed as parameters and return values, and manipulated via TIM bridge operations.</p>
<p>Variables of this type support equality, inequality, and assignment operations: <code>==</code>, <code>!=</code>, <code>=</code></p>
<h3 id="timestamp">timestamp</h3>
<p>A primitive data type representing a specific xtUML time. Variables created via a <code>TIM::current_clock</code> statement are of this type. timestamps may be stored in class attributes, passed as parameters and return values.</p>
<p>Variables of this type support equality, inequality, comparison, and assignment operations: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>=</code></p>
<h3 id="masltype">MASLtype</h3>
<p>A primitive data type created in converted MASL models. This serves as the base type for MASL types and collections that do not directly map to an xtUML core type (e.g. integer). MASLtype is a UDT whose core type is string.</p>
<h2 id="user-data-types">User Data Types</h2>
<p>A type based on another type. User data types (UDTs) may be based on virtually any existing type. User data types inherit all operators from the primitive type and are completely compatible and interchangeable with the base type. UDTs allow the modeler to give a more meaningful type name to a lower level type.</p>
<h3 id="user-data-type-ranges">User Data Type Ranges</h3>
<p>Ranges are contraints used to limit the extent of values that may be represented by a model element defined with the constrained type. A range is composed of a minimum and a maximum value. Ranges are most often applied to numeric (real and integer including enumerations) types which is the case for this capability in BridgePoint.</p>
<h4 id="udt-range-capabilities">UDT Range Capabilities</h4>
<ul>
<li>Range data is stored in the model and can be made available to downstream model compilation tool chains.<br />
</li>
<li>A <strong>Minimum</strong> and a <strong>Maximum</strong> range setting are supported.<br />
Note that minimum and maximum range settings are <em>inclusive</em>, meaning that the minimum value of the range is the lowest legal value to be taken by an element linked to the ranged type. The maximum value of the range is the maximum legal value.<br />
</li>
<li>A <strong>Minimum</strong> setting, <strong>Maximum</strong> setting or <strong>both</strong> settings can be supplied to define the range for the User Data Type.</li>
</ul>
<div class="figure">
<img src="range_cme1.png" alt="Range Context Menu" />
<p class="caption">Range Context Menu</p>
</div>
<ul>
<li>A context menu is available on numeric User Data Types eligible to be constrained with Range information. The context menu has multiple levels ending with 3 capabilities:</li>
</ul>
<ol style="list-style-type: decimal">
<li>Set the Minimum Range value.<br />
</li>
<li>Set the Maximum Range value.<br />
</li>
<li>Clear the Range values (eliminating the Range altogether).<br />
The 'Clear' menu item will show only when a Range has been established for the selected User Data Type.</li>
</ol>
<div class="figure">
<img src="range_cme3.png" alt="Range Maximum Setting" />
<p class="caption">Range Maximum Setting</p>
</div>
<ul>
<li>To view the range values for a selected User Data Type, simply navigate the context menu to the Minimum and Maximum values as when setting the values. This displays the existing value setting. Range values also are displayed on the canvas and in the Properties view.</li>
</ul>
<h2 id="structured-data-types">Structured Data Types</h2>
<p>A structured data type (SDT) is a collection of structure members of various types. Structure members are accessed via the “.” operator. SDTs may be used as return values, parameters, or class attributes. Automatic (transient) variables become SDTs when initialized to a return value or variable whose type is an SDT. Only the assignment operation is valid on the SDT itself. The individual structure members may be operated on according to the valid operations for their respective types.</p>
<h2 id="enumerations">Enumerations</h2>
<p>A data type that can take on one of a list of uniquely named values (enumerators) at any one time. Variables of the enumeration type may only be assigned one of the corresponding enumerators as a value. Enumerators are accessed in OAL using <code>&lt;enumeration name&gt;::&lt;enumerator name&gt;</code> with full scoping to avoid name conflicts with transients, constants, class attributes, etc.</p>
<p>Variables of an enumeration type support equality, inequality, and assignment operations: <code>==</code>, <code>!=</code>, <code>=</code></p>
<h2 id="constant-specifications">Constant specifications</h2>
<p>Constant specifications are groupings of related constants. Constant specifications may be named or unnamed. The name, if any exists, may be used to qualify constant references in OAL in the case where there exist multiple constants with the same name. Constant specifications are composed of zero to many Constants. A constant has a name, type, and value. The type is restricted to primitive types integer, real, boolean, or string and enumerated types. The type may also be a UDT which is based on one of the types listed above or another UDT which is based on one of the types listed above. The value is restricted to meaningful data based on the chosen type. Integer constant values may be specified in either decimal, hexadecimal (beginning with 0x), or binary (beginning with 0b).</p>
</body>
</html>
