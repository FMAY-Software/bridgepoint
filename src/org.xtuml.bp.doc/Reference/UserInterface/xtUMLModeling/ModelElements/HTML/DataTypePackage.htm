<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="../../../../../github-pandoc.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="data-types">Data Types</h1>
<p>Data types fall into the following categories:</p>
<ul>
<li>Primitive types</li>
<li>User data types</li>
<li>Structured data types</li>
<li>Enumerations</li>
<li>Constant specifications</li>
</ul>
<h2 id="primitive-types">Primitive types</h2>
<p>Primitive types are built-in and provided by BridgePoint. You cannot add to, or<br />
remove from the set of primitive types. The primitive types are:</p>
<h3 id="void">void</h3>
<p>A primitive data type representing emptiness or nothingness.</p>
<h3 id="boolean">boolean</h3>
<p>An enumeration whose only allowable values are true and false. This type is a<br />
core data type that supports the following operators: and, or, and not.</p>
<h3 id="integer">integer</h3>
<p>A primitive data type whose literal values represent whole numbers, i.e., 1, 2,<br />
3, and so on. The integer type supports the following arithmetic operations:<br />
<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, unary operations: <code>+</code>, <code>-</code>, and comparison operations:<br />
<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</p>
<h3 id="real">real</h3>
<p>A primitive data type whose literal values represent real numbers, i.e., those<br />
that can contain a fractional part as in: 1.0, 2.4, 3.14159, and so on. The real<br />
type supports the following arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>,<br />
unary operations: <code>+</code>, <code>-</code>, and comparison operations: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>,<br />
<code>&lt;=</code>, <code>&gt;=</code>.</p>
<h3 id="string">string</h3>
<p>A primitive data type used to define a sequence of characters. A literal string<br />
is always enclosed in a set of double quotes, for example “abcdefg”. String<br />
types support concatenation (+ operator) and the following lexical comparisons:<br />
<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</p>
<h3 id="unique_id">unique_id</h3>
<p>A primitive data type that provides an arbitrary value generated by the system<br />
and guaranteed to be unique across all instances of the same class. Modelers<br />
should use an arbitrary identifier (aka unique_id) when using natural<br />
identifying attributes is either not possible or cumbersome. Only equality (<code>==</code>)<br />
and inequality (<code>!=</code>) operators are supported.</p>
<h3 id="statestate_model">state&lt;State_Model&gt;</h3>
<p>A primitive data type used internally by xtUML to keep track of the current<br />
state of classes with state diagrams. Variables of this type cannot be<br />
manipulated or assigned by the user.</p>
<h3 id="same_asbase_attribute">same_as&lt;Base_Attribute&gt;</h3>
<p>A primitive data type used internally by xtUML to make sure association<br />
referential attributes use the same type on both sides of the association.<br />
Variables of this type cannot be manipulated or assigned by the user.</p>
<h3 id="inst_refobject">inst_ref&lt;Object&gt;</h3>
<p>A primitive data type representing a reference to a modeled class. Variables<br />
created via a “create object instance”, ”select one“ or “select any” statement<br />
are of this type. Class attributes are accessed via the “.” operator.</p>
<h3 id="inst_ref_setobject">inst_ref_set&lt;Object&gt;</h3>
<p>A primitive data type representing a collection of references to a modeled<br />
class. Variables created via a ”select many” statement are of this type. Each<br />
element in the collection is of type <code>inst_ref&lt;Object&gt;</code>.</p>
<h3 id="instevent">inst&lt;Event&gt;</h3>
<p>A primitive data type representing a reference to a modeled event. Variables<br />
created via a “create event instance” statement are of this type.</p>
<h3 id="instmapping">inst&lt;Mapping&gt;</h3>
<p>A primitive data type from which a user-defined type can be derived, an instance<br />
mapping is used when an xtUML model requires access to a data structure in<br />
another xtUML model or legacy code. Although there are no hard and set rules for<br />
when to use an instance mapping over an instance reference mapping, the decision<br />
usually revolves around the operations supported.</p>
<p>Instance mappings are commonly used when manipulating the data structure as a<br />
whole.</p>
<p>All comparison operations are available for instance mappings in OAL: <code>==</code>,<br />
<code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>. However, due to their implementation-specific<br />
nature, Verifier cannot use variables of this type in a meaningful way.</p>
<p>The implementation of mappings and the markings used to realize them are<br />
provided by the BridgePoint Compiler. See the documentation for the marking<br />
MapDataTypeAsPointer in <code>&lt;project&gt;/gen/datatype.mark</code> for additional<br />
information.</p>
<h3 id="inst_refmapping">inst_ref&lt;Mapping&gt;</h3>
<p>A primitive data type from which a user-defined type is derived, an instance<br />
reference mapping is used when an xtUML model requires access to a data<br />
structure in another xtUML model or legacy code. Although there are no hard and<br />
set rules for when to use an instance reference mapping over an instance<br />
mapping, the decision usually revolves around the operations supported.</p>
<p>Instance reference mappings are commonly used when manipulating the data<br />
structure by reference.</p>
<p>The equality and inequality operators are available for instance reference<br />
mappings in OAL: <code>==</code>, <code>!=</code>. However, due to their implementation-specific<br />
nature, Verifier cannot use variables of this type in a meaningful way.</p>
<p>The implementation of mappings and the markings used to realize them are<br />
provided by the BridgePoint Compiler. See the documentation for the marking<br />
MapDataTypeAsPointer in <code>&lt;project&gt;/gen/datatype.mark</code> for additional<br />
information.</p>
<h3 id="component_ref">component_ref</h3>
<p>A primitive data type representing a reference to a modeled component. The<br />
sender keyword in OAL is always of this type. This type may be used the same<br />
place other primitive data types are used. It is also valid in OAL as the<br />
target in a “send ... to <component_ref>” command when performing<br />
inter-component messaging. Class attributes, parameters, return values, and<br />
transients may all use this type.</p>
<p>Variables of this type support equality and inequality operations in Verifier:<br />
<code>==</code>, <code>!=</code></p>
<p>Variables of this type are not yet supported in MC-3020.</p>
<h3 id="date">date</h3>
<p>A primitive data type representing an xtUML date. Variables created via a<br />
“TIM::create_date” or “TIM::current_date” statement are of this type. dates may<br />
be stored in class attributes, passed as parameters and return values, and<br />
manipulated via TIM bridge operations.</p>
<p>Variables of this type support equality, inequality, comparison, and assignment<br />
operations: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>=</code></p>
<h3 id="inst_reftimer">inst_ref&lt;Timer&gt;</h3>
<p>A primitive data type representing a reference to a xtUML timer. Variables<br />
created via a “TIM::timer_start” or “TIM::timer_start_recurring” statement are<br />
of this type. Timer references may be stored in class attributes, passed as<br />
parameters and return values, and manipulated via TIM bridge operations.</p>
<p>Variables of this type support equality, inequality, and assignment operations:<br />
<code>==</code>, <code>!=</code>, <code>=</code></p>
<h3 id="timestamp">timestamp</h3>
<p>A primitive data type representing a specific xtUML time. Variables created via<br />
a “TIM::current_clock” statement are of this type. timestamps may be stored in<br />
class attributes, passed as parameters and return values.</p>
<p>Variables of this type support equality, inequality, comparison, and assignment<br />
operations: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>=</code></p>
<h2 id="user-data-types">User data types</h2>
<p>A type based on one of the primitive data types. User data types (UDTs) may be<br />
based on the following primitive types: <code>boolean</code>, <code>integer</code>, <code>real</code>, <code>string</code>,<br />
<code>unique_id</code>, <code>inst&lt;Mapping&gt;</code>, and <code>inst_ref&lt;Mapping&gt;</code>. User data types inherit<br />
all operators from the primitive type and are completely compatible and<br />
interchangeable with their primitive type. UDTs allow the modeler to give a<br />
more meaningful type name to a core type. In some programming languages, this<br />
feature is known as a “typedef”.</p>
<h2 id="structured-data-types">Structured data types</h2>
<p>A structured data type (SDT) is a collection of structure members of various<br />
types. Structure members are accessed via the “.” operator. SDTs may be used as<br />
return values, parameters, or class attributes. Automatic (transient) variables<br />
become SDTs when initialized to a return value or variable whose type is an SDT.<br />
Only the assignment operation is valid on the SDT itself. The individual<br />
structure members may be operated on according to the valid operations for their<br />
respective types.</p>
<h2 id="enumerations">Enumerations</h2>
<p>A data type that can take on one of a list of uniquely named values<br />
(enumerators) at any one time. Variables of the enumeration type may only be<br />
assigned one of the corresponding enumerators as a value. Enumerators are<br />
accessed in OAL using <code>&lt;enumeration name&gt;::&lt;enumerator name&gt;</code> with full scoping<br />
to avoid name conflicts with transients, constants, class attributes, etc.</p>
<p>Variables of an enumeration type support equality, inequality, and assignment<br />
operations: <code>==</code>, <code>!=</code>, <code>=</code></p>
<h2 id="constant-specifications">Constant specifications</h2>
<p>Constant specifications are groupings of related constants. Constant<br />
specifications may be named or unnamed. The name, if any exists, may be used to<br />
qualify constant references in OAL in the case where there exist multiple<br />
constants with the same name. Constant specifications are composed of zero to<br />
many Constants. A constant has a name, type, and value. The type is restricted<br />
to primitive types integer, real, boolean, or string and enumerated types. The<br />
type may also be a UDT which is based on one of the types listed above or<br />
another UDT which is based on one of the types listed above. The value is<br />
restricted to meaningful data based on the chosen type. Integer constant values<br />
may be specified in either decimal, hexadecimal (beginning with 0x), or binary<br />
(beginning with 0b).</p>
</body>
</html>
